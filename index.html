<!DOCTYPE html>
<html lang="th">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Solar Simulator Pro Thai - ระบบจำลองโซล่าเซลล์</title>
	<meta name="apple-mobile-web-app-title" content="Solar Simulator">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <link rel="apple-touch-icon" href="icon-180x180.png">
    <meta name="mobile-web-app-capable" content="yes">
    <!-- React & Babel CDNs -->
    <script src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
    <script src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <!-- Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Lucide Icons -->
    <script src="https://unpkg.com/lucide@latest"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Sarabun:wght@300;400;700&display=swap');
        body { 
            font-family: 'Sarabun', sans-serif; 
            touch-action: none; 
        }
        .grid-bg {
            background-image: radial-gradient(#cbd5e1 1px, transparent 1px);
            background-size: 24px 24px;
        }
        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 20px;
            height: 20px;
            background: #2563eb;
            cursor: pointer;
            border-radius: 50%;
            border: 3px solid white;
            box-shadow: 0 2px 4px rgba(0,0,0,0.3);
        }
        .wire-shadow { filter: drop-shadow(0 2px 2px rgba(0,0,0,0.2)); }
        .animate-spin-fast {
            animation: spin 0.5s linear infinite;
        }
        @keyframes spin {
            from { transform: rotate(0deg); }
            to { transform: rotate(360deg); }
        }
        .no-select {
            -webkit-user-select: none;
            user-select: none;
        }
        .hide-scrollbar::-webkit-scrollbar { display: none; }
        .hide-scrollbar { -ms-overflow-style: none; scrollbar-width: none; }
    </style>
</head>
<body class="bg-slate-100 overflow-hidden no-select">
    <div id="root"></div>

    <script type="text/babel">
        const { useState, useEffect, useRef, useMemo } = React;

        const Icon = ({ name, size = 16, className = "", strokeWidth = 2, ...props }) => {
            const iconRef = useRef(null);
            useEffect(() => {
                if (iconRef.current) {
                    lucide.createIcons({
                        attrs: {
                            class: className,
                            width: size,
                            height: size,
                            'stroke-width': strokeWidth
                        },
                        nameAttr: 'data-lucide'
                    });
                }
            }, [name, size, className, strokeWidth]);
            return <i data-lucide={name} ref={iconRef} className={className} {...props}></i>;
        };

        // --- Configuration ---
        const COMPONENT_TYPES = {
            PANEL: 'panel', BATTERY: 'battery', CHARGER: 'charger', INVERTER: 'inverter',
            BREAKER_DC: 'breaker_dc', FUSE: 'fuse', DC_SURGE: 'dc_surge', AC_BREAKER: 'ac_breaker',
            AC_SURGE: 'ac_surge', ENERGY_METER: 'energy_meter', DC_WATT_METER: 'dc_watt_meter', AC_SOURCE: 'ac_source', 
            GROUND_BAR: 'ground_bar', TERMINAL_BLOCK_POS: 'terminal_block_pos', TERMINAL_BLOCK_NEG: 'terminal_block_neg', 
            SOCKET: 'socket', BULB: 'bulb', MOTOR: 'motor'
        };

        const COLORS = {
            POS: '#ef4444', // Red (สีแดง) - Positive
            NEG: '#2563eb', // Blue (สีน้ำเงิน) - Negative
            AC_L: '#854d0e', // Brown
            AC_N: '#3b82f6', // Standard Blue
            G: '#16a34a'    // Green
        };

        const SPECS = {
            [COMPONENT_TYPES.PANEL]: { label: 'แผง PV', icon: 'sun', width: 120, height: 160, terminals: [{id: 'pos', x: 40, color: COLORS.POS}, {id: 'neg', x: 80, color: COLORS.NEG}], editable: 'maxVoltage', unit: 'V', min: 12, max: 100, step: 1 },
            [COMPONENT_TYPES.BATTERY]: { label: 'แบตเตอรี่', icon: 'battery', width: 110, height: 130, terminals: [{id: 'pos', x: 30, color: COLORS.POS}, {id: 'neg', x: 80, color: COLORS.NEG}], editable: 'capacity', unit: 'Ah', min: 5, max: 500, step: 5 },
            [COMPONENT_TYPES.CHARGER]: { label: 'ชาร์จเจอร์', icon: 'battery-charging', width: 180, height: 120, terminals: [{id: 'pv_pos', label: 'PV+', x: 25, color: COLORS.POS}, {id: 'pv_neg', label: 'PV-', x: 50, color: COLORS.NEG}, {id: 'bat_pos', label: 'BAT+', x: 90, color: COLORS.POS}, {id: 'bat_neg', label: 'BAT-', x: 115, color: COLORS.NEG}, {id: 'load_pos', label: 'LOAD+', x: 145, color: COLORS.POS}, {id: 'load_neg', label: 'LOAD-', x: 170, color: COLORS.NEG}] },
            [COMPONENT_TYPES.INVERTER]: { label: 'อินเวอร์เตอร์', icon: 'activity', width: 150, height: 110, terminals: [{id: 'dc_pos', label: 'DC+', x: 30, color: COLORS.POS}, {id: 'dc_neg', label: 'DC-', x: 55, color: COLORS.NEG}, {id: 'ac_l', label: 'L', x: 105, color: COLORS.AC_L}, {id: 'ac_n', label: 'N', x: 130, color: COLORS.AC_N}] },
            [COMPONENT_TYPES.BREAKER_DC]: { label: 'DC Breaker', icon: 'power', width: 120, height: 100, terminals: [{id: 'in_1', label: 'เข้า', x: 30, color: COLORS.POS}, {id: 'in_2', label: 'เข้า', x: 50, color: COLORS.NEG}, {id: 'out_1', label: 'ออก', x: 70, color: COLORS.POS}, {id: 'out_2', label: 'ออก', x: 90, color: COLORS.NEG}] },
            [COMPONENT_TYPES.ENERGY_METER]: { label: 'AC Meter', icon: 'gauge', width: 130, height: 100, terminals: [{id: 'in_l', label: 'L-เข้า', x: 25, color: COLORS.AC_L}, {id: 'in_n', label: 'N-เข้า', x: 50, color: COLORS.AC_N}, {id: 'out_l', label: 'L-ออก', x: 85, color: COLORS.AC_L}, {id: 'out_n', label: 'N-ออก', x: 105, color: COLORS.AC_N}] },
            [COMPONENT_TYPES.DC_WATT_METER]: { label: 'DC Meter', icon: 'activity', width: 130, height: 100, terminals: [{id: 'in_pos', label: 'IN+', x: 25, color: COLORS.POS}, {id: 'in_neg', label: 'IN-', x: 45, color: COLORS.NEG}, {id: 'out_pos', label: 'OUT+', x: 85, color: COLORS.POS}, {id: 'out_neg', label: 'OUT-', x: 105, color: COLORS.NEG}] },
            [COMPONENT_TYPES.AC_BREAKER]: { label: 'AC Breaker', icon: 'power', width: 120, height: 100, terminals: [{id: 'in_l', label: 'L-เข้า', x: 30, color: COLORS.AC_L}, {id: 'in_n', label: 'N-เข้า', x: 50, color: COLORS.AC_N}, {id: 'out_l', label: 'L-ออก', x: 70, color: COLORS.AC_L}, {id: 'out_n', label: 'N-ออก', x: 90, color: COLORS.AC_N}] },
            [COMPONENT_TYPES.DC_SURGE]: { label: 'DC SPD', icon: 'shield-alert', width: 90, height: 90, terminals: [{id: 'pos', label: '+', x: 25, color: COLORS.POS}, {id: 'neg', label: '-', x: 45, color: COLORS.NEG}, {id: 'g', label: 'G', x: 65, color: COLORS.G}] },
            [COMPONENT_TYPES.AC_SURGE]: { label: 'AC SPD', icon: 'shield-check', width: 90, height: 90, terminals: [{id: 'l', label: 'L', x: 25, color: COLORS.AC_L}, {id: 'n', label: 'N', x: 45, color: COLORS.AC_N}, {id: 'g', label: 'G', x: 65, color: COLORS.G}] },
            [COMPONENT_TYPES.FUSE]: { label: 'DC Fuse', icon: 'shield-check', width: 80, height: 60, terminals: [{id: 'in', label: 'เข้า', x: 20, color: COLORS.POS}, {id: 'out', label: 'ออก', x: 60, color: COLORS.POS}] },
            [COMPONENT_TYPES.GROUND_BAR]: { label: 'Ground Bar', icon: 'database', width: 160, height: 45, terminals: [{id: 'g1', x: 25, color: COLORS.G}, {id: 'g2', x: 55, color: COLORS.G}, {id: 'g3', x: 85, color: COLORS.G}, {id: 'g4', x: 115, color: COLORS.G}, {id: 'g5', x: 145, color: COLORS.G}] },
            [COMPONENT_TYPES.TERMINAL_BLOCK_POS]: { label: 'จุดพ่วง (+)', icon: 'circle-dot', width: 100, height: 40, terminals: [{id: 't1', x: 20, color: COLORS.POS}, {id: 't2', x: 40, color: COLORS.POS}, {id: 't3', x: 60, color: COLORS.POS}, {id: 't4', x: 80, color: COLORS.POS}] },
            [COMPONENT_TYPES.TERMINAL_BLOCK_NEG]: { label: 'จุดพ่วง (-)', icon: 'circle-dot', width: 100, height: 40, terminals: [{id: 't1', x: 20, color: COLORS.NEG}, {id: 't2', x: 40, color: COLORS.NEG}, {id: 't3', x: 60, color: COLORS.NEG}, {id: 't4', x: 80, color: COLORS.NEG}] },
            [COMPONENT_TYPES.AC_SOURCE]: { label: 'AC Source', icon: 'zap', width: 110, height: 110, terminals: [{id: 'l', label: 'L', x: 30, color: COLORS.AC_L}, {id: 'n', label: 'N', x: 55, color: COLORS.AC_N}, {id: 'g', label: 'G', x: 80, color: COLORS.G}] },
            [COMPONENT_TYPES.BULB]: { label: 'หลอดไฟ', icon: 'lightbulb', width: 90, height: 110, terminals: [{id: 'l', label: 'L', x: 30, color: COLORS.AC_L}, {id: 'n', label: 'N', x: 60, color: COLORS.AC_N}], editable: 'watts', unit: 'W', min: 5, max: 200, step: 5 },
            [COMPONENT_TYPES.MOTOR]: { label: 'มอเตอร์', icon: 'fan', width: 110, height: 110, terminals: [{id: 'l', label: '+', x: 35, color: COLORS.POS}, {id: 'n', label: '-', x: 75, color: COLORS.NEG}], editable: 'watts', unit: 'W', min: 10, max: 500, step: 10 },
            [COMPONENT_TYPES.SOCKET]: { label: 'เต้ารับ', icon: 'power', width: 80, height: 80, terminals: [{id: 'l', label: 'L', x: 25, color: COLORS.AC_L}, {id: 'n', label: 'N', x: 55, color: COLORS.AC_N}], editable: 'watts', unit: 'W', min: 100, max: 2000, step: 50 },
        };

        const getWirePath = (x1, y1, x2, y2, offX = 0, offY = 40) => {
            const midY = Math.max(y1, y2) + offY;
            const midX = (x1 + x2) / 2 + offX;
            return `M ${x1} ${y1} L ${x1} ${midY} L ${midX} ${midY} L ${x2} ${midY} L ${x2} ${y2}`;
        };

        // --- Visual Components ---
        const Terminal = ({ x, y, color, label, onPointerDown, isHovered }) => (
            <g transform={`translate(${x}, ${y})`} onPointerDown={(e) => { e.stopPropagation(); onPointerDown(e); }} className="cursor-crosshair">
                <circle r="25" fill="transparent" /> 
                <g className={`transition-all duration-200 origin-center ${isHovered ? 'scale-150' : ''}`}>
                    <rect x="-7" y="-7" width="14" height="14" fill="#374151" rx="2" stroke={isHovered ? "#fbbf24" : "none"} strokeWidth={2} />
                    <circle r="5" fill={color} stroke="white" strokeWidth="1.5" />
                </g>
                {label && <text x="0" y={isHovered ? 28 : 22} textAnchor="middle" fill={isHovered ? "#000" : "#4b5563"} fontSize="8" fontWeight="bold" className="pointer-events-none uppercase">{label}</text>}
            </g>
        );

        const PVPanelVisual = ({ width, height, sunIntensity, maxVoltage }) => (
            <g>
                <rect x="0" y="0" width={width} height={height} fill={`rgb(30, 58, ${180 + (sunIntensity/2)})`} stroke="#cbd5e1" strokeWidth="2" />
                <g stroke="rgba(255,255,255,0.4)" strokeWidth="1">
                    <line x1="0" y1={height/4} x2={width} y2={height/4} /><line x1="0" y1={height/2} x2={width} y2={height/2} />
                    <line x1="0" y1={height*0.75} x2={width} y2={height*0.75} /><line x1={width/2} y1="0" x2={width/2} y2={height} />
                </g>
                <text x={width/2} y={height/2} textAnchor="middle" fill="white" opacity="0.8" fontSize="12" fontWeight="bold">PV {maxVoltage}V</text>
            </g>
        );

        const BatteryVisual = ({ width, height, soc = 75, isCharging }) => (
            <g>
                <rect x="5" y="10" width={width-10} height={height-10} rx="6" fill="#1f2937" stroke="#374151" strokeWidth="2" />
                <rect x="20" y="0" width="20" height="12" fill="#dc2626" rx="2" />
                <rect x={width-40} y="0" width="20" height="12" fill="#111827" rx="2" />
                <rect x="15" y="45" width={width-30} height={55} rx="3" fill="#374151" stroke="#4b5563" />
                <rect x="18" y="48" width={(width-36)*(soc/100)} height={49} rx="2" fill={soc > 20 ? "#22c55e" : "#ef4444"} opacity="0.9" />
                <text x={width/2} y="78" textAnchor="middle" fill="white" fontSize="16" fontWeight="bold">{Math.round(soc)}%</text>
                {isCharging && (
                    <g transform={`translate(${width/2 - 12}, 25)`}>
                         <circle r="12" fill="#fef08a" stroke="#ca8a04" strokeWidth="1" className="animate-pulse" />
                         <path d="M-2 -5 L4 -5 L-1 1 L3 1 L-3 8 L-1 2 L-5 2 Z" fill="#ca8a04" transform="translate(6, 4) scale(1.2)" />
                    </g>
                )}
            </g>
        );

        const ChargerVisual = ({ width, height, isCharging, hasLoad }) => (
            <g>
                <rect x="0" y="0" width={width} height={height} rx="12" fill="#0ea5e9" stroke="#0369a1" strokeWidth="2" />
                <rect x="25" y="20" width={width-50} height="40" rx="4" fill="#ecfccb" stroke="#84cc16" strokeWidth="1.5" />
                <text x={width/2} y="47" textAnchor="middle" fill="#365314" fontSize="14" fontWeight="bold" fontFamily="monospace">{isCharging ? "CHARGING" : "STANDBY"}</text>
                <circle cx={40} cy="80" r="5" fill={isCharging ? "#22c55e" : "#1e293b"} />
                <text x={50} y="84" fill="white" fontSize="9" fontWeight="bold">Charge</text>
                <circle cx={width-80} cy="80" r="5" fill={hasLoad ? "#ef4444" : "#1e293b"} />
                <text x={width-70} y="84" fill="white" fontSize="9" fontWeight="bold">Load</text>
            </g>
        );

        const FuseVisual = ({ width, height }) => (
            <g>
                <rect x="10" y="20" width={width-20} height={20} rx="4" fill="#f8fafc" stroke="#64748b" strokeWidth="2" />
                <rect x="25" y="23" width={width-50} height="14" fill="#fef3c7" stroke="#d97706" />
                <line x1="25" y1="30" x2={width-25} y2="30" stroke="#b45309" strokeWidth="1" strokeDasharray="2 1" />
                <text x={width/2} y="15" textAnchor="middle" fill="#475569" fontSize="8" fontWeight="bold">DC FUSE</text>
            </g>
        );

        const MotorVisual = ({ width, height, isPowered }) => (
            <g>
                <rect x="10" y="20" width={width-20} height={height-40} rx="8" fill="#4b5563" stroke="#374151" strokeWidth="2" />
                <circle cx={width/2} cy={height/2} r="30" fill="#374151" stroke="#94a3b8" strokeWidth="2" />
                <g transform={`translate(${width/2}, ${height/2})`}>
                    <path d="M-15 0 L15 0 M0 -15 L0 15" stroke="white" strokeWidth="3" className={isPowered ? "animate-spin-fast origin-center" : ""} />
                </g>
                <text x={width/2} y="15" textAnchor="middle" fill="#475569" fontSize="9" fontWeight="bold">MOTOR</text>
            </g>
        );

        const BulbVisual = ({ width, height, isPowered }) => (
            <g>
                <path d={`M ${width/2-10} ${height-10} L ${width/2+10} ${height-10} L ${width/2+15} ${height-30} L ${width/2-15} ${height-30} Z`} fill="#94a3b8" />
                <circle cx={width/2} cy={height/2-5} r="25" fill={isPowered ? "#fef08a" : "#f1f5f9"} stroke={isPowered ? "#facc15" : "#cbd5e1"} strokeWidth={2} />
                {isPowered && <circle cx={width/2} cy={height/2-5} r="32" fill="none" stroke="#fef08a" strokeWidth="2" opacity="0.5" className="animate-pulse" />}
            </g>
        );

        const SocketVisual = ({ width, height, isPowered }) => (
            <g>
                <rect x="0" y="0" width={width} height={height} rx="8" fill="#f8fafc" stroke="#cbd5e1" strokeWidth="2" />
                <circle cx={width*0.3} cy={height/2} r="5" fill="#1e293b" />
                <circle cx={width*0.7} cy={height/2} r="5" fill="#1e293b" />
                <circle cx={width/2} cy={height*0.75} r="4" fill="#1e293b" />
                {isPowered && <circle cx={width-15} cy="15" r="3" fill="#22c55e" className="animate-pulse" />}
            </g>
        );

        const SurgeVisual = ({ width, height, label, color }) => (
            <g>
                <rect x="0" y="0" width={width} height={height} rx="4" fill={color} stroke="#1e293b" strokeWidth="2" />
                <rect x="10" y="10" width={width - 20} height={height / 2} rx="2" fill="white" opacity="0.2" />
                <text x={width/2} y={height - 15} textAnchor="middle" fill="white" fontSize="10" fontWeight="bold">{label}</text>
            </g>
        );

        const AcMeterVisual = ({ width, height, volts, watts }) => (
            <g>
                <rect x="0" y="0" width={width} height={height} rx="4" fill="#1e293b" stroke="#0f172a" strokeWidth="2" />
                <rect x="10" y="10" width={width-20} height={55} fill="#0f172a" stroke="#334155" />
                <text x="15" y="25" fill="#38bdf8" fontSize="10" fontFamily="monospace">VOLT: {volts.toFixed(1)} V</text>
                <text x="15" y="38" fill="#fbbf24" fontSize="10" fontFamily="monospace">CURR: {volts > 0 ? (watts/volts).toFixed(2) : "0.00"} A</text>
                <text x="15" y="51" fill="#4ade80" fontSize="10" fontFamily="monospace">POWR: {Math.round(watts)} W</text>
                <text x="15" y="64" fill="#a78bfa" fontSize="10" fontFamily="monospace">ENER: {(watts*0.1).toFixed(0)} Wh</text>
                <text x={width/2} y={height - 10} textAnchor="middle" fill="#94a3b8" fontSize="9" fontWeight="bold">AC ENERGY METER</text>
            </g>
        );

        const DcWattMeterVisual = ({ width, height, volts, watts }) => (
            <g>
                <rect x="0" y="0" width={width} height={height} rx="4" fill="#1e293b" stroke="#334155" strokeWidth="2" />
                <rect x="10" y="10" width={width-20} height={55} fill="#0f172a" stroke="#334155" />
                {/* Screen content */}
                <text x="15" y="25" fill="#38bdf8" fontSize="10" fontFamily="monospace">VOLT: {volts.toFixed(1)} V</text>
                <text x="15" y="38" fill="#fbbf24" fontSize="10" fontFamily="monospace">CURR: {volts > 0 ? (watts/Math.max(volts,1)).toFixed(2) : "0.00"} A</text>
                <text x="15" y="51" fill="#4ade80" fontSize="10" fontFamily="monospace">POWR: {Math.round(watts)} W</text>
                <text x="15" y="64" fill="#a78bfa" fontSize="10" fontFamily="monospace">ENER: {(watts*0.1).toFixed(0)} Wh</text>
                
                <text x={width/2} y={height-10} textAnchor="middle" fill="#64748b" fontSize="9" fontWeight="bold">DC POWER METER</text>
            </g>
        );

        const BoxVisual = ({ width, height, label, isPowered }) => (
            <g>
                <rect x="0" y="0" width={width} height={height} rx="6" fill="white" stroke="#374151" strokeWidth="2" />
                <rect x="0" y="0" width={width} height="30" rx="6" fill="#f1f5f9" />
                <text x={width/2} y="20" textAnchor="middle" fill="#0f172a" fontSize="11" fontWeight="bold">{label.split(' (')[0]}</text>
                <circle cx={width - 15} cy="15" r="5" fill={isPowered ? "#22c55e" : "#cbd5e1"} />
            </g>
        );

        const GroundBarVisual = ({ width, height }) => (
            <g>
                <rect x="0" y="0" width={width} height={height} rx="4" fill="#16a34a" stroke="#15803d" strokeWidth="2" />
                {[25, 55, 85, 115, 145].map(cx => ( <circle key={cx} cx={cx} cy={height/2} r="5" fill="#15803d" stroke="#052e16" strokeWidth="1" /> ))}
            </g>
        );

        const TerminalBlockVisual = ({ width, height, color, label }) => (
            <g>
                <rect x="0" y="0" width={width} height={height} rx="4" fill={color} stroke="#0f172a" strokeWidth="2" />
                <rect x="5" y="5" width={width-10} height={height-10} rx="2" fill="rgba(255,255,255,0.2)" stroke="rgba(255,255,255,0.4)" strokeWidth="1" />
                {[20, 40, 60, 80].map(cx => ( <circle key={cx} cx={cx} cy={height/2} r="4" fill="white" stroke="#475569" strokeWidth="2" /> ))}
                <text x={width/2} y={-5} textAnchor="middle" fill="#475569" fontSize="9" fontWeight="bold">{label}</text>
            </g>
        );

        const App = () => {
            const [components, setComponents] = useState([]);
            const [wires, setWires] = useState([]); 
            const [sunIntensity, setSunIntensity] = useState(80);
            const [dragInfo, setDragInfo] = useState(null); 
            const [tempWire, setTempWire] = useState(null);
            const [hoveredTerm, setHoveredTerm] = useState(null);
            const [selectedObj, setSelectedObj] = useState(null); 
            const [isRunning, setIsRunning] = useState(false);
            const [simResults, setSimResults] = useState({ voltages: new Map(), states: {}, batteryDrainWatts: 0 });
            const [masterLoadOn, setMasterLoadOn] = useState(true); 
            const [tick, setTick] = useState(0);

            // Use refs to store latest values for the interval to access without resetting
            const simResultsRef = useRef(simResults);
            const sunIntensityRef = useRef(sunIntensity);

            // Update refs when state changes
            useEffect(() => { simResultsRef.current = simResults; }, [simResults]);
            useEffect(() => { sunIntensityRef.current = sunIntensity; }, [sunIntensity]);

            const canvasRef = useRef(null);

            const getLocalPos = (e) => {
                if (!canvasRef.current) return { x: 0, y: 0 };
                const rect = canvasRef.current.getBoundingClientRect();
                return { x: e.clientX - rect.left, y: e.clientY - rect.top };
            };

            // Noise and Animation Tick
            useEffect(() => {
                const i = setInterval(() => setTick(t => (t + 1) % 100), 400); // 400ms tick for values
                return () => clearInterval(i);
            }, []);

            // --- Simulation Logic ---
            useEffect(() => {
                const nets = [];
                const getNet = (id) => nets.find(s => s.has(id));
                
                // Initialize Nets
                components.forEach(c => {
                    const spec = SPECS[c.type];
                    if(spec?.terminals) spec.terminals.forEach(t => {
                        const s = new Set(); s.add(`${c.id}_${t.id}`); nets.push(s);
                    });
                });
                
                // Merge Nets via Wires
                wires.forEach(w => {
                    const n1 = getNet(`${w.from}_${w.fromTerm}`);
                    const n2 = getNet(`${w.to}_${w.toTerm}`);
                    if(n1 && n2 && n1 !== n2) { n2.forEach(i => n1.add(i)); nets.splice(nets.indexOf(n2), 1); }
                });

                // Merge Nets via Internal Connections
                components.forEach(c => {
                    if ([COMPONENT_TYPES.GROUND_BAR, COMPONENT_TYPES.TERMINAL_BLOCK_POS, COMPONENT_TYPES.TERMINAL_BLOCK_NEG].includes(c.type)) {
                        const termIds = SPECS[c.type].terminals.map(t => `${c.id}_${t.id}`);
                        if (termIds.length > 1) {
                            let commonNet = getNet(termIds[0]);
                            for (let i = 1; i < termIds.length; i++) {
                                const targetNet = getNet(termIds[i]);
                                if (commonNet && targetNet && commonNet !== targetNet) {
                                    targetNet.forEach(item => commonNet.add(item));
                                    nets.splice(nets.indexOf(targetNet), 1);
                                }
                            }
                        }
                    }
                });

                const netVoltages = new Map();
                const compStates = {};
                let currentBatteryDrain = 0;
                let currentAcWatts = 0; 
                let batteryChargingWatts = 0;

                // Noise factors (fluctuate slightly every tick)
                const noiseV = (Math.random() - 0.5) * 0.2; // +/- 0.1V
                const noiseW = (Math.random() - 0.5) * 5;   // +/- 2.5W

                // Step 1: Identify Battery & PV State
                const batteries = components.filter(c => c.type === COMPONENT_TYPES.BATTERY);
                const panels = components.filter(c => c.type === COMPONENT_TYPES.PANEL);
                const hasBattery = batteries.length > 0;

                // --- Calculate PV Voltage ---
                panels.forEach(pv => {
                    const maxV = pv.maxVoltage || 40;
                    // Add noise to PV voltage
                    const v = (maxV * (sunIntensity/100)) + noiseV; 
                    const pos = getNet(`${pv.id}_pos`); const neg = getNet(`${pv.id}_neg`);
                    if(!netVoltages.has(neg)) netVoltages.set(neg, 0);
                    netVoltages.set(pos, (netVoltages.get(neg)||0) + v);
                });

                // --- Calculate Battery Voltage (Complex Model) ---
                // We need to know if we are charging or discharging to set the voltage.
                // This is a simplified iterative approach.
                // 1. Assume resting voltage based on SOC
                // 2. See if Charger is active (PV > Bat). If so, voltage rises.
                // 3. See if Loads are active. If so, voltage sags.
                
                let systemBatVoltage = 0;
                
                batteries.forEach(bat => {
                   if((bat.soc !== undefined ? bat.soc : 50) > 0) { 
                       const pos = getNet(`${bat.id}_pos`); const neg = getNet(`${bat.id}_neg`);
                       if(!netVoltages.has(neg)) netVoltages.set(neg, 0);

                       // Base Voltage (SOC curve)
                       let soc = bat.soc || 50;
                       let baseV = 11.8 + (soc / 100) * 1.0; // 11.8V to 12.8V

                       // Check Charger State (simplified)
                       // Find if any charger is connected to this battery net
                       // And if that charger has PV input
                       // For simplicity in this loop, we just check global PV state + connection later
                       // Here we just set a "Potential" voltage
                       
                       // We will set the final voltage after determining load/charge state in the component loop
                       // For now, set a preliminary voltage to allow current to flow
                       netVoltages.set(pos, baseV); 
                       systemBatVoltage = baseV;
                   }
                });

                components.filter(c => c.type === COMPONENT_TYPES.AC_SOURCE).forEach(src => {
                    const l = getNet(`${src.id}_l`); const n = getNet(`${src.id}_n`);
                    netVoltages.set(n, 0); netVoltages.set(l, 220 + noiseV*5); // AC noise is higher
                });
                
                // Propagate Voltages & Calculate States
                // Run multiple passes to allow voltage to stabilize across breakers/fuses
                for(let pass=0; pass<3; pass++) {
                    components.forEach(c => {
                         // Voltage Propagation
                        if([COMPONENT_TYPES.AC_BREAKER, COMPONENT_TYPES.BREAKER_DC, COMPONENT_TYPES.FUSE, COMPONENT_TYPES.DC_WATT_METER, COMPONENT_TYPES.ENERGY_METER].includes(c.type)) {
                            let pairs = [];
                            if (c.type === COMPONENT_TYPES.AC_BREAKER || c.type === COMPONENT_TYPES.ENERGY_METER) pairs = [['in_l', 'out_l'], ['in_n', 'out_n']];
                            else if (c.type === COMPONENT_TYPES.FUSE) pairs = [['in', 'out']];
                            else if (c.type === COMPONENT_TYPES.DC_WATT_METER) pairs = [['in_pos', 'out_pos'], ['in_neg', 'out_neg']];
                            else pairs = [['in_1', 'out_1'], ['in_2', 'out_2']]; 

                            pairs.forEach(([iId, oId]) => {
                                const nI = getNet(`${c.id}_${iId}`); const nO = getNet(`${c.id}_${oId}`);
                                if(netVoltages.has(nI)) netVoltages.set(nO, netVoltages.get(nI));
                                else if(netVoltages.has(nO)) netVoltages.set(nI, netVoltages.get(nO));
                            });
                        }
                    });
                }

                // --- Calculate Loads and Adjust Voltages ---
                // We iterate components again to determine state and real voltages
                
                // First: Check Charger
                let isSystemCharging = false;
                components.filter(c => c.type === COMPONENT_TYPES.CHARGER).forEach(c => {
                    const pvp = getNet(`${c.id}_pv_pos`);
                    const batp = getNet(`${c.id}_bat_pos`);
                    const loadp = getNet(`${c.id}_load_pos`);
                    
                    const vpv = netVoltages.get(pvp) || 0;
                    const vbat = netVoltages.get(batp) || 0;
                    
                    // Charging Logic: PV must be > Battery + overhead
                    const isCharging = vpv > (vbat + 1.0) && vpv > 13;
                    
                    if(isCharging) {
                        isSystemCharging = true;
                        // Boost Battery Voltage when charging (Voltage Swell)
                        // Higher sun = higher swell
                        const chargeBoost = 0.5 + (sunIntensity/100) * 1.0 + noiseV;
                        const newBatV = Math.min(14.4, systemBatVoltage + chargeBoost);
                        
                        // Update net voltage for battery
                        if(batp) netVoltages.set(batp, newBatV);
                        // Also set load terminal to regulated 12V (or Vbat)
                        if(loadp) netVoltages.set(loadp, 12.0 + noiseV); 
                    } else {
                        // Not charging, battery is at resting or sagging voltage
                        // Load terminal gets battery voltage
                        if(loadp && vbat > 10.5) netVoltages.set(loadp, vbat);
                    }
                    
                    // Check if load terminal has a connection
                    const hasWireOnLoad = wires.some(w => (w.from === c.id && w.fromTerm === 'load_pos') || (w.to === c.id && w.toTerm === 'load_pos'));
                    
                    compStates[c.id] = { isCharging, hasLoad: hasWireOnLoad && (vbat > 10 || isCharging) };
                });

                // Second: Check Loads & Inverter
                components.forEach(c => {
                     if(c.type === COMPONENT_TYPES.INVERTER) {
                        const acl = getNet(`${c.id}_ac_l`); const dcp = getNet(`${c.id}_dc_pos`);
                        const vIn = netVoltages.get(dcp) || 0;
                        if(vIn > 11) { 
                            netVoltages.set(acl, 220 + noiseV*5); 
                            compStates[c.id] = { isPowered: true }; 
                            
                            // Inverter Self Consumption
                            currentBatteryDrain += 10 + Math.abs(noiseW); 
                        }
                    }
                });
                
                // Check Consumers
                components.forEach(c => {
                     if(['bulb','socket','motor'].includes(c.type)) {
                        const l = getNet(`${c.id}_l`); const n = getNet(`${c.id}_n`);
                        const v = Math.abs((netVoltages.get(l)||0) - (netVoltages.get(n)||0));
                        
                        if (v > 10 && masterLoadOn) { 
                            // Add noise to watts calculation
                            const nominalWatts = c.watts || 100;
                            const actualWatts = nominalWatts + noiseW;
                            
                            compStates[c.id] = { isPowered: true, volts: v };
                            
                            if (c.type === COMPONENT_TYPES.MOTOR) {
                                // DC Load (Connected to Battery/Charger)
                                currentBatteryDrain += actualWatts;
                            } else {
                                // AC Load (Connected via Inverter)
                                const anyInverterOn = components.some(x => x.type === COMPONENT_TYPES.INVERTER && compStates[x.id]?.isPowered);
                                if (anyInverterOn) {
                                    currentAcWatts += actualWatts;
                                    // Inverter Efficiency Loss (e.g. 90% efficient)
                                    // Battery must supply Watts / 0.9
                                    currentBatteryDrain += (actualWatts / 0.9);
                                }
                            }
                        } else {
                            compStates[c.id] = { isPowered: false, volts: v };
                        }
                    }
                });

                // Final Pass: Voltage Sag due to Load
                // If heavy load, drop the battery net voltage
                if (currentBatteryDrain > 0 && hasBattery) {
                    const sag = (currentBatteryDrain / 2000) * 1.0; // Max 1V sag at 2000W
                    batteries.forEach(bat => {
                        const pos = getNet(`${bat.id}_pos`);
                        const currentV = netVoltages.get(pos);
                        if (currentV && !isSystemCharging) { // Only sag if not actively being pushed by charger
                             netVoltages.set(pos, Math.max(10.5, currentV - sag));
                        }
                    });
                }
                
                // Meters Display Update
                components.forEach(c => {
                    if(c.type === COMPONENT_TYPES.ENERGY_METER) {
                        const l = getNet(`${c.id}_in_l`); const n = getNet(`${c.id}_in_n`);
                        const v = Math.abs((netVoltages.get(l)||0) - (netVoltages.get(n)||0));
                        const w = (v > 100) ? currentAcWatts : 0;
                        // Add jitter to display
                        const displayV = v > 0 ? v + (Math.random()-0.5)*2 : 0;
                        const displayW = w > 0 ? w + (Math.random()-0.5)*5 : 0;
                        compStates[c.id] = { volts: displayV, watts: displayW };
                    }
                    if(c.type === COMPONENT_TYPES.DC_WATT_METER) {
                        const p = getNet(`${c.id}_in_pos`); const n = getNet(`${c.id}_in_neg`);
                        const v = Math.abs((netVoltages.get(p)||0) - (netVoltages.get(n)||0));
                        const w = (v > 10) ? currentBatteryDrain : 0; 
                        
                        const displayV = v > 0 ? v + (Math.random()-0.5)*0.1 : 0;
                        const displayW = w > 0 ? w + (Math.random()-0.5)*5 : 0;
                        
                        compStates[c.id] = { volts: displayV, watts: displayW };
                    }
                });

                setSimResults({ voltages: netVoltages, states: compStates, batteryDrainWatts: currentBatteryDrain });
            }, [components, wires, sunIntensity, masterLoadOn, tick]); // Re-run on tick

            // --- Battery SOC Interval ---
            useEffect(() => {
                let interval;
                if (isRunning) {
                    interval = setInterval(() => {
                        setComponents(prev => prev.map(c => {
                            if (c.type === COMPONENT_TYPES.BATTERY) {
                                let newSoc = c.soc !== undefined ? c.soc : 50;
                                const currentSim = simResultsRef.current;
                                const currentSun = sunIntensityRef.current;
                                
                                // Charging Logic
                                const isCharging = Object.values(currentSim.states).some(s => s.isCharging);
                                if (isCharging) {
                                    newSoc += (currentSun / 100) * 0.8; 
                                }

                                // Discharging Logic
                                if (currentSim.batteryDrainWatts > 0) {
                                    const drainRate = (currentSim.batteryDrainWatts / 1000) * 0.8; 
                                    newSoc -= drainRate;
                                } else if (!isCharging && c.soc > 0) {
                                    newSoc -= 0.01; // Self discharge
                                }

                                return { ...c, soc: Math.min(100, Math.max(0, newSoc)) };
                            }
                            return c;
                        }));
                    }, 200);
                }
                return () => clearInterval(interval);
            }, [isRunning]);

            const handlePointerMove = (e) => {
                const pos = getLocalPos(e);
                if(dragInfo?.type === 'comp') setComponents(prev => prev.map(c => c.id === dragInfo.id ? {...c, x: pos.x - dragInfo.offsetX, y: pos.y - dragInfo.offsetY} : c));
                if(dragInfo?.type === 'wireHandle') setWires(prev => prev.map(w => w.id === dragInfo.id ? { ...w, offsetX: pos.x - dragInfo.baseX, offsetY: pos.y - dragInfo.baseY } : w));
                if(tempWire) setTempWire(prev => ({...prev, x2: pos.x, y2: pos.y}));
                let hit = null;
                components.forEach(c => {
                    const spec = SPECS[c.type];
                    spec.terminals?.forEach(t => {
                        const d = Math.hypot(pos.x - (c.x + t.x), pos.y - (c.y + spec.height + 5));
                        if(d < 25) hit = { compId: c.id, termId: t.id };
                    });
                });
                setHoveredTerm(hit);
            };

            const addComponent = (type) => {
                setComponents(prev => [...prev, { id: Date.now().toString(), type, x: 200, y: 200, watts: 100, efficiency: 100, capacity: 100, soc: 50, maxVoltage: 40 }]);
                setSelectedObj(null);
            };

            const deleteObj = (obj) => {
                if(obj.type === 'comp') {
                    setComponents(prev => prev.filter(c => c.id !== obj.id));
                    setWires(prev => prev.filter(w => w.from !== obj.id && w.to !== obj.id));
                } else if (obj.type === 'wire') {
                    setWires(prev => prev.filter(w => w.id !== obj.id));
                }
                setSelectedObj(null);
            };

            const getSelectedSpec = () => {
                if (selectedObj?.type !== 'comp') return null;
                const comp = components.find(c => c.id === selectedObj.id);
                if (!comp) return null;
                return SPECS[comp.type];
            };

            const selectedSpec = getSelectedSpec();

            return (
                <div className="flex flex-col h-screen overflow-hidden" onPointerMove={handlePointerMove} onPointerUp={() => { if(tempWire && hoveredTerm) setWires(p => [...p, { id: Date.now(), from: tempWire.from, fromTerm: tempWire.fromTerm, to: hoveredTerm.compId, toTerm: hoveredTerm.termId, offsetX: 0, offsetY: 40 }]); setTempWire(null); setDragInfo(null); }} onClick={() => setSelectedObj(null)}>
                    
                    {/* Horizontal Toolbar */}
                    <div className="h-20 bg-slate-900 shadow-xl flex items-center px-4 gap-6 z-50 shrink-0 overflow-hidden" onClick={e => e.stopPropagation()}>
                        <div className="flex items-center gap-3 border-r border-slate-700 pr-4 h-12">
                            <div className="text-yellow-400 bg-slate-800 p-2 rounded-lg"><Icon name="zap" size={24} className="fill-current" /></div>
                            <button onClick={() => setIsRunning(!isRunning)} className={`flex items-center gap-2 px-4 py-2 rounded-lg font-bold transition-all shadow-lg ${isRunning ? 'bg-red-500 text-white hover:bg-red-600' : 'bg-green-600 text-white hover:bg-green-700'}`}>
                                <Icon name={isRunning ? 'rotate-ccw' : 'play'} size={18} />
                                <span className="whitespace-nowrap text-sm">{isRunning ? 'หยุด' : 'เริ่มจำลอง'}</span>
                            </button>
                            <button onClick={() => setMasterLoadOn(!masterLoadOn)} className={`flex items-center gap-2 px-3 py-2 rounded-lg font-bold transition-all shadow-lg ${masterLoadOn ? 'bg-blue-600 hover:bg-blue-700 text-white' : 'bg-slate-700 text-slate-400'}`}>
                                <Icon name="power" size={18} />
                                <span className="whitespace-nowrap text-xs">โหลด {masterLoadOn ? 'ON' : 'OFF'}</span>
                            </button>
                        </div>
                        <div className="flex flex-col border-r border-slate-700 pr-4 min-w-[120px]">
                            <span className="text-[10px] text-slate-400 font-bold uppercase tracking-widest">แสงแดด: {sunIntensity}%</span>
                            <input type="range" min="0" max="100" value={sunIntensity} onChange={(e) => setSunIntensity(parseInt(e.target.value))} className="w-full mt-1 accent-yellow-400 cursor-pointer"/>
                        </div>
                        <div className="flex-1 flex items-center gap-2 overflow-x-auto whitespace-nowrap hide-scrollbar py-2">
                            {Object.keys(SPECS).map(key => (
                                <button key={key} onClick={() => addComponent(key)} className="flex items-center gap-2 px-3 py-2 bg-slate-800 hover:bg-blue-600 text-white rounded-lg border border-slate-700 transition-all group shrink-0">
                                    <Icon name={SPECS[key].icon} size={14} className="group-hover:scale-110" />
                                    <span className="text-[11px] font-bold">{SPECS[key].label}</span>
                                </button>
                            ))}
                        </div>
                    </div>

                    {/* Canvas Area */}
                    <div ref={canvasRef} className="flex-1 relative grid-bg overflow-hidden touch-none h-full">
                        {/* Selection HUD */}
                        {selectedObj && (
                            <div className="absolute top-4 right-4 z-50 bg-white/95 backdrop-blur-md p-4 rounded-2xl shadow-2xl border-2 border-blue-400 w-64 animate-in slide-in-from-right duration-200" onClick={e => e.stopPropagation()}>
                                <div className="flex justify-between items-center mb-3">
                                    <h3 className="font-bold text-slate-800 flex items-center gap-2">
                                        <Icon name="settings" size={16}/> 
                                        {selectedObj.type === 'comp' ? SPECS[components.find(c => c.id === selectedObj.id)?.type]?.label : 'แก้ไขสายไฟ'}
                                    </h3>
                                    <button onClick={() => deleteObj(selectedObj)} className="bg-red-50 text-red-500 p-2 rounded-full hover:bg-red-500 hover:text-white"><Icon name="trash-2" size={18} /></button>
                                </div>
                                {selectedObj.type === 'comp' && components.find(c => c.id === selectedObj.id) && selectedSpec?.editable && (
                                    <div className="space-y-2">
                                        <input 
                                            type="range" 
                                            min={selectedSpec.min || 10} 
                                            max={selectedSpec.max || 2000} 
                                            step={selectedSpec.step || 5} 
                                            value={components.find(c => c.id === selectedObj.id)[selectedSpec.editable]} 
                                            onChange={(e) => setComponents(prev => prev.map(c => c.id === selectedObj.id ? { ...c, [selectedSpec.editable]: parseInt(e.target.value) } : c))} 
                                            className="w-full h-8 cursor-pointer accent-blue-600"
                                        />
                                        <div className="text-center font-black text-blue-600 text-2xl">
                                            {components.find(c => c.id === selectedObj.id)[selectedSpec.editable]} {selectedSpec.unit}
                                        </div>
                                    </div>
                                )}
                                {selectedObj.type === 'wire' && (
                                    <div className="text-center text-xs text-slate-500">ลากจุดสีน้ำเงินเพื่อจัดสายไฟ</div>
                                )}
                            </div>
                        )}

                        <svg className="absolute inset-0 w-full h-full pointer-events-none overflow-visible">
                            {wires.map(w => {
                                const c1 = components.find(c => c.id === w.from); const c2 = components.find(c => c.id === w.to);
                                if(!c1 || !c2) return null;
                                const t1 = SPECS[c1.type].terminals.find(t => t.id === w.fromTerm);
                                const t2 = SPECS[c2.type].terminals.find(t => t.id === w.toTerm);
                                const p1 = { x: c1.x + t1.x, y: c1.y + SPECS[c1.type].height + 5 };
                                const p2 = { x: c2.x + t2.x, y: c2.y + SPECS[c2.type].height + 5 };
                                const isSel = selectedObj?.type === 'wire' && selectedObj.id === w.id;
                                const path = getWirePath(p1.x, p1.y, p2.x, p2.y, w.offsetX || 0, w.offsetY || 40);
                                const wireColor = t1.color; // Use the terminal color directly
                                
                                return (
                                    <g key={w.id} className="pointer-events-auto cursor-pointer" onClick={(e) => { e.stopPropagation(); setSelectedObj({ type: 'wire', id: w.id }); }}>
                                        {/* Hit Area (Invisible but wide for easier clicking) */}
                                        <path d={path} stroke="transparent" strokeWidth="30" fill="none" />
                                        
                                        {/* Wire Halo (Background color stroke to simulate gap when crossing) */}
                                        <path d={path} stroke="#f1f5f9" strokeWidth={isSel ? 12 : 8} fill="none" strokeLinecap="round" />

                                        {/* Main Wire Stroke */}
                                        <path d={path} stroke={isSel ? "#fbbf24" : wireColor} strokeWidth={isSel ? 6 : 3} fill="none" strokeLinecap="round" className="wire-shadow" />
                                        
                                        {/* Drag Handle - Only visible when selected */}
                                        {isSel && (
                                            <g 
                                                transform={`translate(${(p1.x+p2.x)/2 + (w.offsetX || 0)}, ${Math.max(p1.y, p2.y) + (w.offsetY || 40)})`}
                                                onPointerDown={(e) => { 
                                                    e.stopPropagation(); 
                                                    // Calculate base coordinates for the drag
                                                    setDragInfo({ 
                                                        type: 'wireHandle', 
                                                        id: w.id, 
                                                        baseX: (p1.x + p2.x) / 2, 
                                                        baseY: Math.max(p1.y, p2.y) 
                                                    }); 
                                                }}
                                            >
                                                <circle r="15" fill="white" stroke="#3b82f6" strokeWidth="2" className="shadow-lg" />
                                                <g transform="translate(-8, -8)" style={{pointerEvents: 'none'}}> 
                                                    <Icon name="move" size={16} className="text-blue-500" />
                                                </g>
                                            </g>
                                        )}
                                    </g>
                                );
                            })}
                            {tempWire && <path d={getWirePath(tempWire.x1, tempWire.y1, tempWire.x2, tempWire.y2)} stroke="#fbbf24" strokeWidth="4" strokeDasharray="5 5" fill="none" />}
                        </svg>

                        {components.map(comp => {
                            const spec = SPECS[comp.type];
                            const state = simResults.states[comp.id] || {};
                            const isSel = selectedObj?.type === 'comp' && selectedObj.id === comp.id;
                            const isCharging = Object.values(simResults.states).some(s => s.isCharging); // Check global charging for battery visual

                            return (
                                <div key={comp.id} className="absolute z-10" style={{left: comp.x, top: comp.y}}>
                                    <div onPointerDown={(e) => { e.stopPropagation(); const pos = getLocalPos(e); setDragInfo({ type: 'comp', id: comp.id, offsetX: pos.x-comp.x, offsetY: pos.y-comp.y }); setSelectedObj({ type: 'comp', id: comp.id }); }} className={`relative cursor-move transition-all ${isSel ? 'ring-4 ring-blue-500 ring-offset-4 rounded-xl shadow-2xl scale-105' : ''}`}>
                                        {isSel && <button onClick={(e) => { e.stopPropagation(); deleteObj({type:'comp', id: comp.id}); }} className="absolute -top-10 -right-10 bg-red-500 text-white rounded-full p-4 shadow-xl z-50"><Icon name="x" size={20} strokeWidth={3}/></button>}
                                        <svg width={spec.width} height={spec.height + 40} className="overflow-visible drop-shadow-md">
                                            {comp.type === COMPONENT_TYPES.PANEL && <PVPanelVisual width={spec.width} height={spec.height} sunIntensity={sunIntensity} maxVoltage={comp.maxVoltage || 40} />}
                                            {/* Pass isCharging to Battery for Visual Feedback */}
                                            {comp.type === COMPONENT_TYPES.BATTERY && <BatteryVisual width={spec.width} height={spec.height} soc={comp.soc !== undefined ? comp.soc : 50} isCharging={isCharging && comp.soc < 100} />}
                                            {comp.type === COMPONENT_TYPES.CHARGER && <ChargerVisual width={spec.width} height={spec.height} isCharging={state.isCharging} hasLoad={state.hasLoad} />}
                                            {comp.type === COMPONENT_TYPES.FUSE && <FuseVisual width={spec.width} height={spec.height} />}
                                            {comp.type === COMPONENT_TYPES.MOTOR && <MotorVisual width={spec.width} height={spec.height} isPowered={state.isPowered} />}
                                            {comp.type === COMPONENT_TYPES.BULB && <BulbVisual width={spec.width} height={spec.height} isPowered={state.isPowered} />}
                                            {comp.type === COMPONENT_TYPES.SOCKET && <SocketVisual width={spec.width} height={spec.height} isPowered={state.isPowered} />}
                                            {comp.type === COMPONENT_TYPES.DC_SURGE && <SurgeVisual width={spec.width} height={spec.height} label="DC SPD" color="#991b1b" />}
                                            {comp.type === COMPONENT_TYPES.AC_SURGE && <SurgeVisual width={spec.width} height={spec.height} label="AC SPD" color="#166534" />}
                                            {comp.type === COMPONENT_TYPES.GROUND_BAR && <GroundBarVisual width={spec.width} height={spec.height} />}
                                            {comp.type === COMPONENT_TYPES.TERMINAL_BLOCK_POS && <TerminalBlockVisual width={spec.width} height={spec.height} color={COLORS.POS} label="จุดพ่วง (+)" />}
                                            {comp.type === COMPONENT_TYPES.TERMINAL_BLOCK_NEG && <TerminalBlockVisual width={spec.width} height={spec.height} color={COLORS.NEG} label="จุดพ่วง (-)" />}
                                            {comp.type === COMPONENT_TYPES.ENERGY_METER && <AcMeterVisual width={spec.width} height={spec.height} volts={state.volts || 0} watts={state.watts || 0} />}
                                            {comp.type === COMPONENT_TYPES.DC_WATT_METER && <DcWattMeterVisual width={spec.width} height={spec.height} volts={state.volts || 0} watts={state.watts || 0} />}
                                            {['inverter','breaker_dc','ac_breaker','ac_source'].includes(comp.type) && <BoxVisual width={spec.width} height={spec.height} label={spec.label} isPowered={state.isPowered} />}
                                            
                                            {spec.terminals?.map(t => (
                                                <Terminal key={t.id} x={t.x} y={spec.height + 5} color={t.color} label={t.label} isHovered={hoveredTerm?.compId === comp.id && hoveredTerm?.termId === t.id} onPointerDown={(e) => { const pos = getLocalPos(e); setTempWire({ from: comp.id, fromTerm: t.id, x1: comp.x+t.x, y1: comp.y+spec.height+5, x2: pos.x, y2: pos.y }); }} />
                                            ))}
                                        </svg>
                                    </div>
                                </div>
                            );
                        })}
                    </div>
                </div>
            );
        };

        ReactDOM.createRoot(document.getElementById("root")).render(<App />);
    </script>
	<script>
    // ป้องกันไม่ให้คลิกลิงก์แล้วเด้งออกไปเปิดใน Safari
    (function(document,navigator,standalone) {
        if ((standalone in navigator) && navigator[standalone]) {
            var curnode, location=document.location, stop=/^(a|html)$/i;
            document.addEventListener('click', function(e) {
                curnode=e.target;
                while (!(stop).test(curnode.nodeName)) {
                    curnode=curnode.parentNode;
                }
                if('href' in curnode && ( curnode.href.indexOf('http') || ~curnode.href.indexOf(location.host) ) ) {
                    e.preventDefault();
                    location.href = curnode.href;
                }
            },false);
        }
    })(document,window.navigator,'standalone');
</script>
</body>
</html>